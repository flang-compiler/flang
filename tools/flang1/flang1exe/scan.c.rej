--- flang/tools/flang1/flang1exe/scan.c	2017-10-05 15:42:47.450538000 -0700
+++ flang/tools/flang1/flang1exe/scan.c	2017-10-05 15:49:09.936096000 -0700
@@ -7562,10 +7560,10 @@
   is_ppragma = FALSE;
   is_kernel = FALSE;
 
-  for(p=printbuff+8;*p != '\0' && (isblank(*p));) { 
+  for (p = printbuff + 8; *p != '\0' && (isblank(*p));) {
     ++p;
   }
-  leadCount = p - (printbuff+8);
+  leadCount = p - (printbuff + 8);
 
   do {
   again:
@@ -8478,7 +8473,7 @@
   fprintf(astb.astfil, "%d", tk);
   fprintf(astb.astfil, " %d", ctkv); /* default token value */
 
-  currCol = ((int)(currc-stmtb))+leadCount;
+  currCol = ((int)(currc - stmtb)) + leadCount;
 
   switch (tk) {
   case TK_IDENT:
@@ -8507,12 +8502,12 @@
     break;
   case TK_K_ICON:
   case TK_K_LOGCONST:
-    fprintf(astb.astfil, " %d %x %x %d", currCol, CONVAL1G(ctkv), CONVAL2G(ctkv),
-            DTYPEG(ctkv));
+    fprintf(astb.astfil, " %d %x %x %d", currCol, CONVAL1G(ctkv),
+            CONVAL2G(ctkv), DTYPEG(ctkv));
     break;
   case TK_QCON:
-    fprintf(astb.astfil, " %d %x %x %x %x", currCol, CONVAL1G(ctkv), CONVAL2G(ctkv),
-            CONVAL3G(ctkv), CONVAL4G(ctkv));
+    fprintf(astb.astfil, " %d %x %x %x %x", currCol, CONVAL1G(ctkv),
+            CONVAL2G(ctkv), CONVAL3G(ctkv), CONVAL4G(ctkv));
     break;
   case TK_DCCON:
     s1 = CONVAL1G(ctkv);
@@ -8523,19 +8518,20 @@
   case TK_QCCON:
     s1 = CONVAL1G(ctkv);
     s2 = CONVAL2G(ctkv);
-    fprintf(astb.astfil, " %d %x %x %x %x %x %x %x %x", currCol, CONVAL1G(s1), CONVAL2G(s1),
-            CONVAL3G(s1), CONVAL4G(s1), CONVAL1G(s2), CONVAL2G(s2),
-            CONVAL3G(s2), CONVAL4G(s2));
+    fprintf(astb.astfil, " %d %x %x %x %x %x %x %x %x", currCol, CONVAL1G(s1),
+            CONVAL2G(s1), CONVAL3G(s1), CONVAL4G(s1), CONVAL1G(s2),
+            CONVAL2G(s2), CONVAL3G(s2), CONVAL4G(s2));
     break;
   case TK_HOLLERITH:
-    fprintf(astb.astfil, " %d %d", currCol, CONVAL2G(ctkv)); /* kind of hollerith */
-    ctkv = CONVAL1G(ctkv);                       /* auxiliary char constant */
-    goto common_str;                             /* fall thru */
+    fprintf(astb.astfil, " %d %d", currCol,
+            CONVAL2G(ctkv)); /* kind of hollerith */
+    ctkv = CONVAL1G(ctkv);   /* auxiliary char constant */
+    goto common_str;         /* fall thru */
   case TK_FMTSTR:
   case TK_STRING:
   case TK_KSTRING:
     fprintf(astb.astfil, " %d", currCol);
-common_str:
+  common_str:
     len = string_length(DTYPEG(ctkv));
     fprintf(astb.astfil, " %d ", len);
     p = stb.n_base + CONVAL1G(ctkv);
@@ -8564,8 +8560,8 @@
     fprintf(astb.astfil, " %d %d", currCol, gbl.eof_flag);
     break;
   case TK_EOL:
-    currCol = 0; 
-    /* fall through to default case */
+    currCol = 0;
+  /* fall through to default case */
   default:
     fprintf(astb.astfil, " %d", currCol);
     break;
@@ -8580,7 +8576,7 @@
 static INT get_num(int);
 static void get_string(char *);
 
-/** \brief trim white space of source line that has continuations and return 
+/** \brief trim white space of source line that has continuations and return
  * the index of the last character in the source line.
  *
  * This function is called by contIndex().
@@ -8590,10 +8586,10 @@
  * \return the index (an integer) of the last character in the source line.
  */
 static int
-trimContIdx(char * line)
+trimContIdx(char *line)
 {
   int len;
-  char * p;
+  char *p;
 
   if (line == NULL)
     return 0;
@@ -8602,20 +8598,21 @@
   if (len == 0)
     return 0;
 
-  for(p=(line+len)-1; p > line && isspace(*p); --p);
+  for (p = (line + len) - 1; p > line && isspace(*p); --p)
+    ;
 
-  return (int)(p-line);
+  return (int)(p - line);
 }
- 
+
 static int
-numLeadingSpaces(char * line)
+numLeadingSpaces(char *line)
 {
   int i;
- 
+
   if (line == NULL)
     return 0;
-  
-  for(i=0;*line != '\0'; ++line, ++i) {
+
+  for (i = 0; *line != '\0'; ++line, ++i) {
     if (!isspace(*line) && *line != '&')
       break;
   }
@@ -8630,9 +8627,9 @@
  * \param line is the source line that we are processing.
  *
  * \return the index (an integer) of the last character in source line.
- */ 
+ */
 static int
-contIndex(char * line)
+contIndex(char *line)
 {
   int i;
   bool seenText = false;
@@ -8645,7 +8642,7 @@
 
   len = strlen(line);
 
-  for(i=0; i < len; ++i) {
+  for (i = 0; i < len; ++i) {
     if (!seenText && !isspace(line[i]) && line[i] != '&') {
       seenText = TRUE;
     }
@@ -8660,8 +8657,8 @@
     } else if (seenQuote != 0 && line[i] == seenQuote) {
       seenQuote = 0;
     } else if (seenQuote == 0 && (line[i] == '!' || line[i] == '&')) {
-      seenFin = true; 
-      return i+1;
+      seenFin = true;
+      return i + 1;
     }
   }
 
@@ -8686,24 +8683,23 @@
   *
   * \param contNo is greater than zero when source line is a continuation of
   * the source line specified in line.
-  * 
+  *
   * \return the source line associated with line. Result is NULL if line not
   * found in source file. Caller is responsible to free the memory allocated
   * for the result.
   */
 char *
-get_src_line(int line, char **src_file, int col, int *srcCol, 
-             int *contNo)
+get_src_line(int line, char **src_file, int col, int *srcCol, int *contNo)
 {
   int fr_type, i, scratch_sz = 0, line_sz = 0, srcfile_sz = 0;
-  char * scratch_buf = NULL;
-  char * line_buf = NULL;
-  char * srcfile_buf = NULL;
+  char *scratch_buf = NULL;
+  char *line_buf = NULL;
+  char *srcfile_buf = NULL;
   long offset;
-  int curr_line=0, len;
-  int line_len=0;
+  int curr_line = 0, len;
+  int line_len = 0;
   int adjCol = 0;
-  int is_cont=0;
+  int is_cont = 0;
   int adjSrcLine = 0;
   int saveCol = currCol;
 
@@ -8715,61 +8711,61 @@
       /* EOF */
       break;
     }
-    switch(fr_type) {
-      case FR_LINENO:
-        _rd_tkline(&scratch_buf, &scratch_sz);
-        sscanf(scratch_buf,"%d",&curr_line);
-        break;
-      case FR_SRC:
-        _rd_tkline(&srcfile_buf, &srcfile_sz);
-        if (src_file) {
-          *src_file = srcfile_buf;
-        }
+    switch (fr_type) {
+    case FR_LINENO:
+      _rd_tkline(&scratch_buf, &scratch_sz);
+      sscanf(scratch_buf, "%d", &curr_line);
+      break;
+    case FR_SRC:
+      _rd_tkline(&srcfile_buf, &srcfile_sz);
+      if (src_file) {
+        *src_file = srcfile_buf;
+      }
+      break;
+    case FR_STMT:
+      i = fread((char *)&curr_line, sizeof(int), 1, astb.astfil);
+      if (feof(astb.astfil) || i != 1) {
+        interr("get_src_line: truncated ast file", 0, 4);
         break;
-      case FR_STMT:
-        i = fread((char *)&curr_line, sizeof(int), 1, astb.astfil);
-        if (feof(astb.astfil) || i != 1) {
-          interr("get_src_line: truncated ast file", 0, 4);
-          break;
-        }
-next_stmt:
-        _rd_tkline(&line_buf, &line_sz);
-        if (curr_line == line) {
-
-          adjCol = line_len;
-
-          i = contIndex(line_buf);
-          line_len += (i > 0) ? i : strlen(line_buf);
-          line_len -= (is_cont) ? numLeadingSpaces(line_buf) : 0;
-           
-          if (col < line_len) {
-            if (is_cont) {
-              col = ((col + numLeadingSpaces(line_buf)) - adjCol) + is_cont;
-            }
-            goto fin;
-          } else {
-            ++is_cont;
-            continue;
-          } 
-        } else if (line_buf) {
-          i = sizeof(int);
-          len = (line_sz > i) ? i : line_sz;
-          for(i=0; i < len; ++i)
-            line_buf[i] = '\0';
-          line_len = 0;
-          is_cont = 0;
-        }
-        if (curr_line > line) {
+      }
+    next_stmt:
+      _rd_tkline(&line_buf, &line_sz);
+      if (curr_line == line) {
+
+        adjCol = line_len;
+
+        i = contIndex(line_buf);
+        line_len += (i > 0) ? i : strlen(line_buf);
+        line_len -= (is_cont) ? numLeadingSpaces(line_buf) : 0;
+
+        if (col < line_len) {
+          if (is_cont) {
+            col = ((col + numLeadingSpaces(line_buf)) - adjCol) + is_cont;
+          }
           goto fin;
+        } else {
+          ++is_cont;
+          continue;
         }
-        break;
-      default:
-        if (fr_type > 0 && is_cont > 0) { 
-          /* got a line continuation */
-          adjSrcLine++;
-          goto next_stmt;
-        }
-        _rd_tkline(&scratch_buf, &scratch_sz);
+      } else if (line_buf) {
+        i = sizeof(int);
+        len = (line_sz > i) ? i : line_sz;
+        for (i = 0; i < len; ++i)
+          line_buf[i] = '\0';
+        line_len = 0;
+        is_cont = 0;
+      }
+      if (curr_line > line) {
+        goto fin;
+      }
+      break;
+    default:
+      if (fr_type > 0 && is_cont > 0) {
+        /* got a line continuation */
+        adjSrcLine++;
+        goto next_stmt;
+      }
+      _rd_tkline(&scratch_buf, &scratch_sz);
     }
   }
 fin:
@@ -8783,7 +8779,7 @@
     *contNo = adjSrcLine;
   }
   return line_buf;
-} 
+}
 
 static int
 _read_token(INT *tknv)
@@ -9002,7 +8998,7 @@
     fprintf(gbl.dbgfil, "  TOKEN: %s", tkbuf);
 #endif
   tkntyp = get_num(10);
-  tknval = get_num(10); /* default token value */
+  tknval = get_num(10);  /* default token value */
   currCol = get_num(10); /* get column number */
 
   switch (tkntyp) {
